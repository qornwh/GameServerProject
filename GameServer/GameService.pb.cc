// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameService.proto

#include "GameService.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace protocol {
PROTOBUF_CONSTEXPR Login::Login(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pwd_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoginDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginDefaultTypeInternal() {}
  union {
    Login _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginDefaultTypeInternal _Login_default_instance_;
PROTOBUF_CONSTEXPR CreateAccount::CreateAccount(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.success_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateAccountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateAccountDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateAccountDefaultTypeInternal() {}
  union {
    CreateAccount _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateAccountDefaultTypeInternal _CreateAccount_default_instance_;
PROTOBUF_CONSTEXPR CreateCharacter::CreateCharacter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.charater_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateCharacterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateCharacterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateCharacterDefaultTypeInternal() {}
  union {
    CreateCharacter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateCharacterDefaultTypeInternal _CreateCharacter_default_instance_;
PROTOBUF_CONSTEXPR LoginAccess::LoginAccess(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.charater_)*/{}
  , /*decltype(_impl_.success_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoginAccessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginAccessDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginAccessDefaultTypeInternal() {}
  union {
    LoginAccess _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginAccessDefaultTypeInternal _LoginAccess_default_instance_;
PROTOBUF_CONSTEXPR Charater::Charater(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CharaterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CharaterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CharaterDefaultTypeInternal() {}
  union {
    Charater _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CharaterDefaultTypeInternal _Charater_default_instance_;
PROTOBUF_CONSTEXPR Position::Position(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.yaw_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionDefaultTypeInternal() {}
  union {
    Position _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionDefaultTypeInternal _Position_default_instance_;
PROTOBUF_CONSTEXPR Unit::Unit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.hp_)*/0u
  , /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UnitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnitDefaultTypeInternal() {}
  union {
    Unit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnitDefaultTypeInternal _Unit_default_instance_;
PROTOBUF_CONSTEXPR Player::Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.unit_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerDefaultTypeInternal() {}
  union {
    Player _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerDefaultTypeInternal _Player_default_instance_;
PROTOBUF_CONSTEXPR Monster::Monster(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.unit_)*/nullptr
  , /*decltype(_impl_.state_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MonsterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonsterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonsterDefaultTypeInternal() {}
  union {
    Monster _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonsterDefaultTypeInternal _Monster_default_instance_;
PROTOBUF_CONSTEXPR SLoad::SLoad(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.player_)*/{}
  , /*decltype(_impl_.monster_)*/{}
  , /*decltype(_impl_.room_id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SLoadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SLoadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SLoadDefaultTypeInternal() {}
  union {
    SLoad _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SLoadDefaultTypeInternal _SLoad_default_instance_;
PROTOBUF_CONSTEXPR CLoad::CLoad(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_.is_dummy_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CLoadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CLoadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CLoadDefaultTypeInternal() {}
  union {
    CLoad _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CLoadDefaultTypeInternal _CLoad_default_instance_;
PROTOBUF_CONSTEXPR SInsertplayer::SInsertplayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.player_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SInsertplayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SInsertplayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SInsertplayerDefaultTypeInternal() {}
  union {
    SInsertplayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SInsertplayerDefaultTypeInternal _SInsertplayer_default_instance_;
PROTOBUF_CONSTEXPR SMove::SMove(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_.is_monster_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SMoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SMoveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SMoveDefaultTypeInternal() {}
  union {
    SMove _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SMoveDefaultTypeInternal _SMove_default_instance_;
PROTOBUF_CONSTEXPR SChat::SChat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SChatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SChatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SChatDefaultTypeInternal() {}
  union {
    SChat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SChatDefaultTypeInternal _SChat_default_instance_;
PROTOBUF_CONSTEXPR SPlayerData::SPlayerData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.player_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SPlayerDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SPlayerDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SPlayerDataDefaultTypeInternal() {}
  union {
    SPlayerData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SPlayerDataDefaultTypeInternal _SPlayerData_default_instance_;
PROTOBUF_CONSTEXPR SClosePlayer::SClosePlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SClosePlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SClosePlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SClosePlayerDefaultTypeInternal() {}
  union {
    SClosePlayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SClosePlayerDefaultTypeInternal _SClosePlayer_default_instance_;
PROTOBUF_CONSTEXPR UnitState::UnitState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.monster_)*/nullptr
  , /*decltype(_impl_.player_)*/nullptr
  , /*decltype(_impl_.demage_)*/0
  , /*decltype(_impl_.heal_)*/0
  , /*decltype(_impl_.is_monster_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UnitStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnitStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnitStateDefaultTypeInternal() {}
  union {
    UnitState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnitStateDefaultTypeInternal _UnitState_default_instance_;
PROTOBUF_CONSTEXPR SUnitStates::SUnitStates(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.unit_state_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SUnitStatesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SUnitStatesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SUnitStatesDefaultTypeInternal() {}
  union {
    SUnitStates _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SUnitStatesDefaultTypeInternal _SUnitStates_default_instance_;
PROTOBUF_CONSTEXPR Attack::Attack(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_.skill_code_)*/0
  , /*decltype(_impl_.is_monster_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AttackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttackDefaultTypeInternal() {}
  union {
    Attack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttackDefaultTypeInternal _Attack_default_instance_;
PROTOBUF_CONSTEXPR Buff::Buff(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_.skill_code_)*/0
  , /*decltype(_impl_.is_monster_)*/false
  , /*decltype(_impl_.heal_)*/0
  , /*decltype(_impl_.hp_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BuffDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BuffDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BuffDefaultTypeInternal() {}
  union {
    Buff _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BuffDefaultTypeInternal _Buff_default_instance_;
PROTOBUF_CONSTEXPR CPlayerAttack::CPlayerAttack(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_.skill_code_)*/0
  , /*decltype(_impl_.target_code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CPlayerAttackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CPlayerAttackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CPlayerAttackDefaultTypeInternal() {}
  union {
    CPlayerAttack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CPlayerAttackDefaultTypeInternal _CPlayerAttack_default_instance_;
PROTOBUF_CONSTEXPR SUnitAttack::SUnitAttack(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.attack_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SUnitAttackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SUnitAttackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SUnitAttackDefaultTypeInternal() {}
  union {
    SUnitAttack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SUnitAttackDefaultTypeInternal _SUnitAttack_default_instance_;
PROTOBUF_CONSTEXPR SUnitBuff::SUnitBuff(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.buff_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SUnitBuffDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SUnitBuffDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SUnitBuffDefaultTypeInternal() {}
  union {
    SUnitBuff _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SUnitBuffDefaultTypeInternal _SUnitBuff_default_instance_;
PROTOBUF_CONSTEXPR Demage::Demage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_.demage_)*/0
  , /*decltype(_impl_.is_monster_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DemageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DemageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DemageDefaultTypeInternal() {}
  union {
    Demage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DemageDefaultTypeInternal _Demage_default_instance_;
PROTOBUF_CONSTEXPR SUnitDemage::SUnitDemage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.demage_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SUnitDemageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SUnitDemageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SUnitDemageDefaultTypeInternal() {}
  union {
    SUnitDemage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SUnitDemageDefaultTypeInternal _SUnitDemage_default_instance_;
PROTOBUF_CONSTEXPR SRoomQuest::SRoomQuest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.is_clear_)*/false
  , /*decltype(_impl_.kill_count_)*/0
  , /*decltype(_impl_.sum_kill_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SRoomQuestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SRoomQuestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SRoomQuestDefaultTypeInternal() {}
  union {
    SRoomQuest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SRoomQuestDefaultTypeInternal _SRoomQuest_default_instance_;
PROTOBUF_CONSTEXPR CMovePotal::CMovePotal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pre_room_id_)*/0
  , /*decltype(_impl_.next_room_id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMovePotalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMovePotalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMovePotalDefaultTypeInternal() {}
  union {
    CMovePotal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMovePotalDefaultTypeInternal _CMovePotal_default_instance_;
PROTOBUF_CONSTEXPR SEndGame::SEndGame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.end_game_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SEndGameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SEndGameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SEndGameDefaultTypeInternal() {}
  union {
    SEndGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SEndGameDefaultTypeInternal _SEndGame_default_instance_;
PROTOBUF_CONSTEXPR Item::Item(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.item_code_)*/0
  , /*decltype(_impl_.item_count_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemDefaultTypeInternal() {}
  union {
    Item _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemDefaultTypeInternal _Item_default_instance_;
PROTOBUF_CONSTEXPR DropMessage::DropMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DropMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DropMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DropMessageDefaultTypeInternal() {}
  union {
    DropMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DropMessageDefaultTypeInternal _DropMessage_default_instance_;
PROTOBUF_CONSTEXPR SLoadInventory::SLoadInventory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.gold_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SLoadInventoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SLoadInventoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SLoadInventoryDefaultTypeInternal() {}
  union {
    SLoadInventory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SLoadInventoryDefaultTypeInternal _SLoadInventory_default_instance_;
}  // namespace protocol
static ::_pb::Metadata file_level_metadata_GameService_2eproto[31];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_GameService_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_GameService_2eproto = nullptr;

const uint32_t TableStruct_GameService_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::Login, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::Login, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::protocol::Login, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::protocol::Login, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::protocol::Login, _impl_.pwd_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::CreateAccount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::CreateAccount, _impl_.success_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::CreateCharacter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::CreateCharacter, _impl_.charater_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::LoginAccess, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::LoginAccess, _impl_.success_),
  PROTOBUF_FIELD_OFFSET(::protocol::LoginAccess, _impl_.charater_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::Charater, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::Charater, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::protocol::Charater, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::protocol::Charater, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::Position, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::Position, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::protocol::Position, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::protocol::Position, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::protocol::Position, _impl_.yaw_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::Unit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::Unit, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::protocol::Unit, _impl_.hp_),
  PROTOBUF_FIELD_OFFSET(::protocol::Unit, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::protocol::Unit, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::protocol::Unit, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::Player, _impl_.unit_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::Monster, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::Monster, _impl_.unit_),
  PROTOBUF_FIELD_OFFSET(::protocol::Monster, _impl_.state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SLoad, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SLoad, _impl_.player_),
  PROTOBUF_FIELD_OFFSET(::protocol::SLoad, _impl_.monster_),
  PROTOBUF_FIELD_OFFSET(::protocol::SLoad, _impl_.room_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::CLoad, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::CLoad, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::protocol::CLoad, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::protocol::CLoad, _impl_.is_dummy_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SInsertplayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SInsertplayer, _impl_.player_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SMove, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SMove, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::protocol::SMove, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::protocol::SMove, _impl_.is_monster_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SChat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SChat, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::protocol::SChat, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::protocol::SChat, _impl_.text_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SPlayerData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SPlayerData, _impl_.player_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SClosePlayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SClosePlayer, _impl_.code_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::UnitState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::UnitState, _impl_.monster_),
  PROTOBUF_FIELD_OFFSET(::protocol::UnitState, _impl_.player_),
  PROTOBUF_FIELD_OFFSET(::protocol::UnitState, _impl_.demage_),
  PROTOBUF_FIELD_OFFSET(::protocol::UnitState, _impl_.heal_),
  PROTOBUF_FIELD_OFFSET(::protocol::UnitState, _impl_.is_monster_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SUnitStates, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SUnitStates, _impl_.unit_state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::Attack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::Attack, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::protocol::Attack, _impl_.skill_code_),
  PROTOBUF_FIELD_OFFSET(::protocol::Attack, _impl_.is_monster_),
  PROTOBUF_FIELD_OFFSET(::protocol::Attack, _impl_.position_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::Buff, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::Buff, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::protocol::Buff, _impl_.skill_code_),
  PROTOBUF_FIELD_OFFSET(::protocol::Buff, _impl_.is_monster_),
  PROTOBUF_FIELD_OFFSET(::protocol::Buff, _impl_.heal_),
  PROTOBUF_FIELD_OFFSET(::protocol::Buff, _impl_.hp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::CPlayerAttack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::CPlayerAttack, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::protocol::CPlayerAttack, _impl_.skill_code_),
  PROTOBUF_FIELD_OFFSET(::protocol::CPlayerAttack, _impl_.target_code_),
  PROTOBUF_FIELD_OFFSET(::protocol::CPlayerAttack, _impl_.position_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SUnitAttack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SUnitAttack, _impl_.attack_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SUnitBuff, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SUnitBuff, _impl_.buff_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::Demage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::Demage, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::protocol::Demage, _impl_.demage_),
  PROTOBUF_FIELD_OFFSET(::protocol::Demage, _impl_.is_monster_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SUnitDemage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SUnitDemage, _impl_.demage_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SRoomQuest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SRoomQuest, _impl_.is_clear_),
  PROTOBUF_FIELD_OFFSET(::protocol::SRoomQuest, _impl_.kill_count_),
  PROTOBUF_FIELD_OFFSET(::protocol::SRoomQuest, _impl_.sum_kill_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::CMovePotal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::CMovePotal, _impl_.pre_room_id_),
  PROTOBUF_FIELD_OFFSET(::protocol::CMovePotal, _impl_.next_room_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SEndGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SEndGame, _impl_.end_game_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::Item, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::Item, _impl_.item_code_),
  PROTOBUF_FIELD_OFFSET(::protocol::Item, _impl_.item_count_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::DropMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::DropMessage, _impl_.items_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::SLoadInventory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::protocol::SLoadInventory, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::protocol::SLoadInventory, _impl_.gold_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::protocol::Login)},
  { 10, -1, -1, sizeof(::protocol::CreateAccount)},
  { 17, -1, -1, sizeof(::protocol::CreateCharacter)},
  { 24, -1, -1, sizeof(::protocol::LoginAccess)},
  { 32, -1, -1, sizeof(::protocol::Charater)},
  { 41, -1, -1, sizeof(::protocol::Position)},
  { 51, -1, -1, sizeof(::protocol::Unit)},
  { 62, -1, -1, sizeof(::protocol::Player)},
  { 69, -1, -1, sizeof(::protocol::Monster)},
  { 77, -1, -1, sizeof(::protocol::SLoad)},
  { 86, -1, -1, sizeof(::protocol::CLoad)},
  { 95, -1, -1, sizeof(::protocol::SInsertplayer)},
  { 102, -1, -1, sizeof(::protocol::SMove)},
  { 111, -1, -1, sizeof(::protocol::SChat)},
  { 120, -1, -1, sizeof(::protocol::SPlayerData)},
  { 127, -1, -1, sizeof(::protocol::SClosePlayer)},
  { 134, -1, -1, sizeof(::protocol::UnitState)},
  { 145, -1, -1, sizeof(::protocol::SUnitStates)},
  { 152, -1, -1, sizeof(::protocol::Attack)},
  { 162, -1, -1, sizeof(::protocol::Buff)},
  { 173, -1, -1, sizeof(::protocol::CPlayerAttack)},
  { 183, -1, -1, sizeof(::protocol::SUnitAttack)},
  { 190, -1, -1, sizeof(::protocol::SUnitBuff)},
  { 197, -1, -1, sizeof(::protocol::Demage)},
  { 206, -1, -1, sizeof(::protocol::SUnitDemage)},
  { 213, -1, -1, sizeof(::protocol::SRoomQuest)},
  { 222, -1, -1, sizeof(::protocol::CMovePotal)},
  { 230, -1, -1, sizeof(::protocol::SEndGame)},
  { 237, -1, -1, sizeof(::protocol::Item)},
  { 245, -1, -1, sizeof(::protocol::DropMessage)},
  { 252, -1, -1, sizeof(::protocol::SLoadInventory)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::protocol::_Login_default_instance_._instance,
  &::protocol::_CreateAccount_default_instance_._instance,
  &::protocol::_CreateCharacter_default_instance_._instance,
  &::protocol::_LoginAccess_default_instance_._instance,
  &::protocol::_Charater_default_instance_._instance,
  &::protocol::_Position_default_instance_._instance,
  &::protocol::_Unit_default_instance_._instance,
  &::protocol::_Player_default_instance_._instance,
  &::protocol::_Monster_default_instance_._instance,
  &::protocol::_SLoad_default_instance_._instance,
  &::protocol::_CLoad_default_instance_._instance,
  &::protocol::_SInsertplayer_default_instance_._instance,
  &::protocol::_SMove_default_instance_._instance,
  &::protocol::_SChat_default_instance_._instance,
  &::protocol::_SPlayerData_default_instance_._instance,
  &::protocol::_SClosePlayer_default_instance_._instance,
  &::protocol::_UnitState_default_instance_._instance,
  &::protocol::_SUnitStates_default_instance_._instance,
  &::protocol::_Attack_default_instance_._instance,
  &::protocol::_Buff_default_instance_._instance,
  &::protocol::_CPlayerAttack_default_instance_._instance,
  &::protocol::_SUnitAttack_default_instance_._instance,
  &::protocol::_SUnitBuff_default_instance_._instance,
  &::protocol::_Demage_default_instance_._instance,
  &::protocol::_SUnitDemage_default_instance_._instance,
  &::protocol::_SRoomQuest_default_instance_._instance,
  &::protocol::_CMovePotal_default_instance_._instance,
  &::protocol::_SEndGame_default_instance_._instance,
  &::protocol::_Item_default_instance_._instance,
  &::protocol::_DropMessage_default_instance_._instance,
  &::protocol::_SLoadInventory_default_instance_._instance,
};

const char descriptor_table_protodef_GameService_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021GameService.proto\022\010protocol\"<\n\005Login\022\014"
  "\n\004name\030\001 \001(\t\022\014\n\004type\030\002 \001(\005\022\n\n\002id\030\003 \001(\t\022\013"
  "\n\003pwd\030\004 \001(\t\" \n\rCreateAccount\022\017\n\007success\030"
  "\001 \001(\010\"7\n\017CreateCharacter\022$\n\010charater\030\001 \001"
  "(\0132\022.protocol.Charater\"D\n\013LoginAccess\022\017\n"
  "\007success\030\001 \001(\010\022$\n\010charater\030\002 \003(\0132\022.proto"
  "col.Charater\"4\n\010Charater\022\014\n\004type\030\001 \001(\005\022\014"
  "\n\004code\030\002 \001(\005\022\014\n\004name\030\003 \001(\t\"8\n\010Position\022\t"
  "\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\022\013\n\003yaw\030\004"
  " \001(\002\"b\n\004Unit\022\014\n\004type\030\001 \001(\r\022\n\n\002hp\030\002 \001(\r\022\014"
  "\n\004code\030\003 \001(\005\022$\n\010position\030\004 \001(\0132\022.protoco"
  "l.Position\022\014\n\004name\030\005 \001(\t\"&\n\006Player\022\034\n\004un"
  "it\030\001 \001(\0132\016.protocol.Unit\"6\n\007Monster\022\034\n\004u"
  "nit\030\001 \001(\0132\016.protocol.Unit\022\r\n\005state\030\002 \001(\r"
  "\"^\n\005SLoad\022 \n\006player\030\001 \003(\0132\020.protocol.Pla"
  "yer\022\"\n\007monster\030\002 \003(\0132\021.protocol.Monster\022"
  "\017\n\007room_id\030\003 \001(\005\"M\n\005CLoad\022\014\n\004code\030\001 \001(\005\022"
  "$\n\010position\030d \001(\0132\022.protocol.Position\022\020\n"
  "\010is_dummy\030e \001(\010\"1\n\rSInsertplayer\022 \n\006play"
  "er\030\001 \001(\0132\020.protocol.Player\"O\n\005SMove\022\014\n\004c"
  "ode\030\001 \001(\005\022$\n\010position\030\002 \001(\0132\022.protocol.P"
  "osition\022\022\n\nis_monster\030\003 \001(\010\"1\n\005SChat\022\014\n\004"
  "type\030\001 \001(\r\022\014\n\004code\030\002 \001(\005\022\014\n\004text\030\005 \001(\t\"/"
  "\n\013SPlayerData\022 \n\006player\030\001 \001(\0132\020.protocol"
  ".Player\"\034\n\014SClosePlayer\022\014\n\004code\030\001 \001(\005\"\203\001"
  "\n\tUnitState\022\"\n\007monster\030\001 \001(\0132\021.protocol."
  "Monster\022 \n\006player\030\002 \001(\0132\020.protocol.Playe"
  "r\022\016\n\006demage\030\004 \001(\005\022\014\n\004heal\030\005 \001(\005\022\022\n\nis_mo"
  "nster\030\n \001(\010\"6\n\013SUnitStates\022\'\n\nunit_state"
  "\030\001 \003(\0132\023.protocol.UnitState\"d\n\006Attack\022\014\n"
  "\004code\030\001 \001(\005\022\022\n\nskill_code\030\002 \001(\005\022\022\n\nis_mo"
  "nster\030\003 \001(\010\022$\n\010position\030\004 \001(\0132\022.protocol"
  ".Position\"V\n\004Buff\022\014\n\004code\030\001 \001(\005\022\022\n\nskill"
  "_code\030\002 \001(\005\022\022\n\nis_monster\030\003 \001(\010\022\014\n\004heal\030"
  "\004 \001(\005\022\n\n\002hp\030\005 \001(\005\"l\n\rCPlayerAttack\022\014\n\004co"
  "de\030\001 \001(\005\022\022\n\nskill_code\030\002 \001(\005\022\023\n\013target_c"
  "ode\030\003 \001(\005\022$\n\010position\030\004 \001(\0132\022.protocol.P"
  "osition\"/\n\013SUnitAttack\022 \n\006attack\030\001 \003(\0132\020"
  ".protocol.Attack\")\n\tSUnitBuff\022\034\n\004buff\030\001 "
  "\003(\0132\016.protocol.Buff\":\n\006Demage\022\014\n\004code\030\001 "
  "\001(\005\022\016\n\006demage\030\002 \001(\005\022\022\n\nis_monster\030\003 \001(\010\""
  "/\n\013SUnitDemage\022 \n\006demage\030\001 \001(\0132\020.protoco"
  "l.Demage\"D\n\nSRoomQuest\022\020\n\010is_clear\030\001 \001(\010"
  "\022\022\n\nkill_count\030\002 \001(\005\022\020\n\010sum_kill\030\003 \001(\005\"7"
  "\n\nCMovePotal\022\023\n\013pre_room_id\030\001 \001(\005\022\024\n\014nex"
  "t_room_id\030\002 \001(\005\"\034\n\010SEndGame\022\020\n\010end_game\030"
  "\001 \001(\010\"-\n\004Item\022\021\n\titem_code\030\001 \001(\005\022\022\n\nitem"
  "_count\030\002 \001(\005\",\n\013DropMessage\022\035\n\005items\030\001 \003"
  "(\0132\016.protocol.Item\"=\n\016SLoadInventory\022\035\n\005"
  "items\030\001 \003(\0132\016.protocol.Item\022\014\n\004gold\030\002 \001("
  "\005*\353\002\n\013MessageCode\022\t\n\005LOGIN\020\000\022\n\n\006S_LOAD\020\001"
  "\022\022\n\016S_INSERTPLAYER\020\002\022\n\n\006S_MOVE\020\003\022\n\n\006S_CH"
  "AT\020\004\022\020\n\014S_PLAYERDATA\020\005\022\021\n\rS_CLOSEPLAYER\020"
  "\006\022\020\n\014S_UNITSTATES\020\007\022\022\n\016C_PLAYERATTACK\020\010\022"
  "\020\n\014S_UNITATTACK\020\t\022\020\n\014S_UNITDEMAGE\020\n\022\016\n\nS"
  "_UNITBUFF\020\013\022\017\n\013S_ROOMQUEST\020\014\022\017\n\013C_MOVEPO"
  "TAL\020\r\022\r\n\tS_ENDGAME\020\016\022\017\n\013LOGINACCESS\020\017\022\021\n"
  "\rCREATEACCOUNT\020\020\022\n\n\006C_LOAD\020\021\022\023\n\017CREATECH"
  "ARACTER\020\022\022\017\n\013DROPMESSAGE\020\023\022\023\n\017S_LOADINVE"
  "NTORY\020\024b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_GameService_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_GameService_2eproto = {
    false, false, 2375, descriptor_table_protodef_GameService_2eproto,
    "GameService.proto",
    &descriptor_table_GameService_2eproto_once, nullptr, 0, 31,
    schemas, file_default_instances, TableStruct_GameService_2eproto::offsets,
    file_level_metadata_GameService_2eproto, file_level_enum_descriptors_GameService_2eproto,
    file_level_service_descriptors_GameService_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_GameService_2eproto_getter() {
  return &descriptor_table_GameService_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_GameService_2eproto(&descriptor_table_GameService_2eproto);
namespace protocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageCode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_GameService_2eproto);
  return file_level_enum_descriptors_GameService_2eproto[0];
}
bool MessageCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Login::_Internal {
 public:
};

Login::Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.Login)
}
Login::Login(const Login& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Login* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.pwd_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pwd_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pwd_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pwd().empty()) {
    _this->_impl_.pwd_.Set(from._internal_pwd(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:protocol.Login)
}

inline void Login::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.pwd_){}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pwd_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pwd_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Login::~Login() {
  // @@protoc_insertion_point(destructor:protocol.Login)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Login::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.id_.Destroy();
  _impl_.pwd_.Destroy();
}

void Login::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Login::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.Login)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.id_.ClearToEmpty();
  _impl_.pwd_.ClearToEmpty();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Login::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protocol.Login.name"));
        } else
          goto handle_unusual;
        continue;
      // int32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protocol.Login.id"));
        } else
          goto handle_unusual;
        continue;
      // string pwd = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_pwd();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protocol.Login.pwd"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Login::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Login)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "protocol.Login.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // int32 type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_type(), target);
  }

  // string id = 3;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "protocol.Login.id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_id(), target);
  }

  // string pwd = 4;
  if (!this->_internal_pwd().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pwd().data(), static_cast<int>(this->_internal_pwd().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "protocol.Login.pwd");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_pwd(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Login)
  return target;
}

size_t Login::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.Login)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string id = 3;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string pwd = 4;
  if (!this->_internal_pwd().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pwd());
  }

  // int32 type = 2;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Login::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Login::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Login::GetClassData() const { return &_class_data_; }


void Login::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Login*>(&to_msg);
  auto& from = static_cast<const Login&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.Login)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (!from._internal_pwd().empty()) {
    _this->_internal_set_pwd(from._internal_pwd());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Login::CopyFrom(const Login& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.Login)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Login::IsInitialized() const {
  return true;
}

void Login::InternalSwap(Login* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pwd_, lhs_arena,
      &other->_impl_.pwd_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Login::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[0]);
}

// ===================================================================

class CreateAccount::_Internal {
 public:
};

CreateAccount::CreateAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.CreateAccount)
}
CreateAccount::CreateAccount(const CreateAccount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateAccount* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.success_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.success_ = from._impl_.success_;
  // @@protoc_insertion_point(copy_constructor:protocol.CreateAccount)
}

inline void CreateAccount::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.success_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CreateAccount::~CreateAccount() {
  // @@protoc_insertion_point(destructor:protocol.CreateAccount)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateAccount::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CreateAccount::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateAccount::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.CreateAccount)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.success_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateAccount::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateAccount::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.CreateAccount)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.CreateAccount)
  return target;
}

size_t CreateAccount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.CreateAccount)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateAccount::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateAccount::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateAccount::GetClassData() const { return &_class_data_; }


void CreateAccount::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateAccount*>(&to_msg);
  auto& from = static_cast<const CreateAccount&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.CreateAccount)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateAccount::CopyFrom(const CreateAccount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.CreateAccount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateAccount::IsInitialized() const {
  return true;
}

void CreateAccount::InternalSwap(CreateAccount* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.success_, other->_impl_.success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateAccount::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[1]);
}

// ===================================================================

class CreateCharacter::_Internal {
 public:
  static const ::protocol::Charater& charater(const CreateCharacter* msg);
};

const ::protocol::Charater&
CreateCharacter::_Internal::charater(const CreateCharacter* msg) {
  return *msg->_impl_.charater_;
}
CreateCharacter::CreateCharacter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.CreateCharacter)
}
CreateCharacter::CreateCharacter(const CreateCharacter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateCharacter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.charater_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_charater()) {
    _this->_impl_.charater_ = new ::protocol::Charater(*from._impl_.charater_);
  }
  // @@protoc_insertion_point(copy_constructor:protocol.CreateCharacter)
}

inline void CreateCharacter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.charater_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CreateCharacter::~CreateCharacter() {
  // @@protoc_insertion_point(destructor:protocol.CreateCharacter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateCharacter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.charater_;
}

void CreateCharacter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateCharacter::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.CreateCharacter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.charater_ != nullptr) {
    delete _impl_.charater_;
  }
  _impl_.charater_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateCharacter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protocol.Charater charater = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_charater(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateCharacter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.CreateCharacter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protocol.Charater charater = 1;
  if (this->_internal_has_charater()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::charater(this),
        _Internal::charater(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.CreateCharacter)
  return target;
}

size_t CreateCharacter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.CreateCharacter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protocol.Charater charater = 1;
  if (this->_internal_has_charater()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.charater_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateCharacter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateCharacter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateCharacter::GetClassData() const { return &_class_data_; }


void CreateCharacter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateCharacter*>(&to_msg);
  auto& from = static_cast<const CreateCharacter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.CreateCharacter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_charater()) {
    _this->_internal_mutable_charater()->::protocol::Charater::MergeFrom(
        from._internal_charater());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateCharacter::CopyFrom(const CreateCharacter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.CreateCharacter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateCharacter::IsInitialized() const {
  return true;
}

void CreateCharacter::InternalSwap(CreateCharacter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.charater_, other->_impl_.charater_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateCharacter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[2]);
}

// ===================================================================

class LoginAccess::_Internal {
 public:
};

LoginAccess::LoginAccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.LoginAccess)
}
LoginAccess::LoginAccess(const LoginAccess& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoginAccess* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.charater_){from._impl_.charater_}
    , decltype(_impl_.success_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.success_ = from._impl_.success_;
  // @@protoc_insertion_point(copy_constructor:protocol.LoginAccess)
}

inline void LoginAccess::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.charater_){arena}
    , decltype(_impl_.success_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LoginAccess::~LoginAccess() {
  // @@protoc_insertion_point(destructor:protocol.LoginAccess)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginAccess::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.charater_.~RepeatedPtrField();
}

void LoginAccess::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginAccess::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.LoginAccess)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.charater_.Clear();
  _impl_.success_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginAccess::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .protocol.Charater charater = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_charater(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginAccess::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.LoginAccess)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // repeated .protocol.Charater charater = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_charater_size()); i < n; i++) {
    const auto& repfield = this->_internal_charater(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.LoginAccess)
  return target;
}

size_t LoginAccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.LoginAccess)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.Charater charater = 2;
  total_size += 1UL * this->_internal_charater_size();
  for (const auto& msg : this->_impl_.charater_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bool success = 1;
  if (this->_internal_success() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginAccess::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoginAccess::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginAccess::GetClassData() const { return &_class_data_; }


void LoginAccess::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoginAccess*>(&to_msg);
  auto& from = static_cast<const LoginAccess&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.LoginAccess)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.charater_.MergeFrom(from._impl_.charater_);
  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginAccess::CopyFrom(const LoginAccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.LoginAccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginAccess::IsInitialized() const {
  return true;
}

void LoginAccess::InternalSwap(LoginAccess* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.charater_.InternalSwap(&other->_impl_.charater_);
  swap(_impl_.success_, other->_impl_.success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginAccess::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[3]);
}

// ===================================================================

class Charater::_Internal {
 public:
};

Charater::Charater(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.Charater)
}
Charater::Charater(const Charater& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Charater* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.code_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.code_));
  // @@protoc_insertion_point(copy_constructor:protocol.Charater)
}

inline void Charater::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Charater::~Charater() {
  // @@protoc_insertion_point(destructor:protocol.Charater)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Charater::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void Charater::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Charater::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.Charater)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.code_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.code_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Charater::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protocol.Charater.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Charater::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Charater)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_type(), target);
  }

  // int32 code = 2;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_code(), target);
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "protocol.Charater.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Charater)
  return target;
}

size_t Charater::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.Charater)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 3;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // int32 type = 1;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
  }

  // int32 code = 2;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Charater::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Charater::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Charater::GetClassData() const { return &_class_data_; }


void Charater::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Charater*>(&to_msg);
  auto& from = static_cast<const Charater&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.Charater)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Charater::CopyFrom(const Charater& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.Charater)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Charater::IsInitialized() const {
  return true;
}

void Charater::InternalSwap(Charater* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Charater, _impl_.code_)
      + sizeof(Charater::_impl_.code_)
      - PROTOBUF_FIELD_OFFSET(Charater, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Charater::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[4]);
}

// ===================================================================

class Position::_Internal {
 public:
};

Position::Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.Position)
}
Position::Position(const Position& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Position* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.yaw_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.yaw_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.yaw_));
  // @@protoc_insertion_point(copy_constructor:protocol.Position)
}

inline void Position::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.yaw_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Position::~Position() {
  // @@protoc_insertion_point(destructor:protocol.Position)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Position::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Position::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Position::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.Position)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.yaw_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.yaw_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Position::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float yaw = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Position::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Position)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  // float yaw = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = this->_internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_yaw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Position)
  return target;
}

size_t Position::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.Position)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  // float yaw = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = this->_internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Position::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Position::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Position::GetClassData() const { return &_class_data_; }


void Position::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Position*>(&to_msg);
  auto& from = static_cast<const Position&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.Position)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = from._internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    _this->_internal_set_yaw(from._internal_yaw());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Position::CopyFrom(const Position& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {
  return true;
}

void Position::InternalSwap(Position* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Position, _impl_.yaw_)
      + sizeof(Position::_impl_.yaw_)
      - PROTOBUF_FIELD_OFFSET(Position, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Position::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[5]);
}

// ===================================================================

class Unit::_Internal {
 public:
  static const ::protocol::Position& position(const Unit* msg);
};

const ::protocol::Position&
Unit::_Internal::position(const Unit* msg) {
  return *msg->_impl_.position_;
}
Unit::Unit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.Unit)
}
Unit::Unit(const Unit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Unit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.hp_){}
    , decltype(_impl_.code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::protocol::Position(*from._impl_.position_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.code_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.code_));
  // @@protoc_insertion_point(copy_constructor:protocol.Unit)
}

inline void Unit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.hp_){0u}
    , decltype(_impl_.code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Unit::~Unit() {
  // @@protoc_insertion_point(destructor:protocol.Unit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Unit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.position_;
}

void Unit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Unit::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.Unit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.code_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.code_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Unit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 hp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.hp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .protocol.Position position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protocol.Unit.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Unit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Unit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // uint32 hp = 2;
  if (this->_internal_hp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hp(), target);
  }

  // int32 code = 3;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_code(), target);
  }

  // .protocol.Position position = 4;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // string name = 5;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "protocol.Unit.name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Unit)
  return target;
}

size_t Unit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.Unit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 5;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .protocol.Position position = 4;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // uint32 type = 1;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  // uint32 hp = 2;
  if (this->_internal_hp() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hp());
  }

  // int32 code = 3;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Unit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Unit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Unit::GetClassData() const { return &_class_data_; }


void Unit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Unit*>(&to_msg);
  auto& from = static_cast<const Unit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.Unit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::protocol::Position::MergeFrom(
        from._internal_position());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_hp() != 0) {
    _this->_internal_set_hp(from._internal_hp());
  }
  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Unit::CopyFrom(const Unit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.Unit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Unit::IsInitialized() const {
  return true;
}

void Unit::InternalSwap(Unit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Unit, _impl_.code_)
      + sizeof(Unit::_impl_.code_)
      - PROTOBUF_FIELD_OFFSET(Unit, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Unit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[6]);
}

// ===================================================================

class Player::_Internal {
 public:
  static const ::protocol::Unit& unit(const Player* msg);
};

const ::protocol::Unit&
Player::_Internal::unit(const Player* msg) {
  return *msg->_impl_.unit_;
}
Player::Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.Player)
}
Player::Player(const Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.unit_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_unit()) {
    _this->_impl_.unit_ = new ::protocol::Unit(*from._impl_.unit_);
  }
  // @@protoc_insertion_point(copy_constructor:protocol.Player)
}

inline void Player::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.unit_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Player::~Player() {
  // @@protoc_insertion_point(destructor:protocol.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Player::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.unit_;
}

void Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Player::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.Player)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.unit_ != nullptr) {
    delete _impl_.unit_;
  }
  _impl_.unit_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protocol.Unit unit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_unit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Player::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Player)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protocol.Unit unit = 1;
  if (this->_internal_has_unit()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::unit(this),
        _Internal::unit(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Player)
  return target;
}

size_t Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.Player)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protocol.Unit unit = 1;
  if (this->_internal_has_unit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.unit_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Player::GetClassData() const { return &_class_data_; }


void Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Player*>(&to_msg);
  auto& from = static_cast<const Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.Player)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_unit()) {
    _this->_internal_mutable_unit()->::protocol::Unit::MergeFrom(
        from._internal_unit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Player::CopyFrom(const Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Player::IsInitialized() const {
  return true;
}

void Player::InternalSwap(Player* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.unit_, other->_impl_.unit_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[7]);
}

// ===================================================================

class Monster::_Internal {
 public:
  static const ::protocol::Unit& unit(const Monster* msg);
};

const ::protocol::Unit&
Monster::_Internal::unit(const Monster* msg) {
  return *msg->_impl_.unit_;
}
Monster::Monster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.Monster)
}
Monster::Monster(const Monster& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Monster* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.unit_){nullptr}
    , decltype(_impl_.state_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_unit()) {
    _this->_impl_.unit_ = new ::protocol::Unit(*from._impl_.unit_);
  }
  _this->_impl_.state_ = from._impl_.state_;
  // @@protoc_insertion_point(copy_constructor:protocol.Monster)
}

inline void Monster::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.unit_){nullptr}
    , decltype(_impl_.state_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Monster::~Monster() {
  // @@protoc_insertion_point(destructor:protocol.Monster)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Monster::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.unit_;
}

void Monster::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Monster::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.Monster)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.unit_ != nullptr) {
    delete _impl_.unit_;
  }
  _impl_.unit_ = nullptr;
  _impl_.state_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Monster::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protocol.Unit unit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_unit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Monster::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Monster)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protocol.Unit unit = 1;
  if (this->_internal_has_unit()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::unit(this),
        _Internal::unit(this).GetCachedSize(), target, stream);
  }

  // uint32 state = 2;
  if (this->_internal_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Monster)
  return target;
}

size_t Monster::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.Monster)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protocol.Unit unit = 1;
  if (this->_internal_has_unit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.unit_);
  }

  // uint32 state = 2;
  if (this->_internal_state() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Monster::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Monster::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Monster::GetClassData() const { return &_class_data_; }


void Monster::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Monster*>(&to_msg);
  auto& from = static_cast<const Monster&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.Monster)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_unit()) {
    _this->_internal_mutable_unit()->::protocol::Unit::MergeFrom(
        from._internal_unit());
  }
  if (from._internal_state() != 0) {
    _this->_internal_set_state(from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Monster::CopyFrom(const Monster& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.Monster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Monster::IsInitialized() const {
  return true;
}

void Monster::InternalSwap(Monster* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Monster, _impl_.state_)
      + sizeof(Monster::_impl_.state_)
      - PROTOBUF_FIELD_OFFSET(Monster, _impl_.unit_)>(
          reinterpret_cast<char*>(&_impl_.unit_),
          reinterpret_cast<char*>(&other->_impl_.unit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Monster::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[8]);
}

// ===================================================================

class SLoad::_Internal {
 public:
};

SLoad::SLoad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SLoad)
}
SLoad::SLoad(const SLoad& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SLoad* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.player_){from._impl_.player_}
    , decltype(_impl_.monster_){from._impl_.monster_}
    , decltype(_impl_.room_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.room_id_ = from._impl_.room_id_;
  // @@protoc_insertion_point(copy_constructor:protocol.SLoad)
}

inline void SLoad::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.player_){arena}
    , decltype(_impl_.monster_){arena}
    , decltype(_impl_.room_id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SLoad::~SLoad() {
  // @@protoc_insertion_point(destructor:protocol.SLoad)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SLoad::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.player_.~RepeatedPtrField();
  _impl_.monster_.~RepeatedPtrField();
}

void SLoad::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SLoad::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SLoad)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_.Clear();
  _impl_.monster_.Clear();
  _impl_.room_id_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SLoad::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protocol.Player player = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_player(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .protocol.Monster monster = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_monster(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 room_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.room_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SLoad::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SLoad)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.Player player = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_player_size()); i < n; i++) {
    const auto& repfield = this->_internal_player(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .protocol.Monster monster = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_monster_size()); i < n; i++) {
    const auto& repfield = this->_internal_monster(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 room_id = 3;
  if (this->_internal_room_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_room_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SLoad)
  return target;
}

size_t SLoad::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SLoad)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.Player player = 1;
  total_size += 1UL * this->_internal_player_size();
  for (const auto& msg : this->_impl_.player_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protocol.Monster monster = 2;
  total_size += 1UL * this->_internal_monster_size();
  for (const auto& msg : this->_impl_.monster_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int32 room_id = 3;
  if (this->_internal_room_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_room_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SLoad::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SLoad::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SLoad::GetClassData() const { return &_class_data_; }


void SLoad::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SLoad*>(&to_msg);
  auto& from = static_cast<const SLoad&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SLoad)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.player_.MergeFrom(from._impl_.player_);
  _this->_impl_.monster_.MergeFrom(from._impl_.monster_);
  if (from._internal_room_id() != 0) {
    _this->_internal_set_room_id(from._internal_room_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SLoad::CopyFrom(const SLoad& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SLoad)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SLoad::IsInitialized() const {
  return true;
}

void SLoad::InternalSwap(SLoad* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.player_.InternalSwap(&other->_impl_.player_);
  _impl_.monster_.InternalSwap(&other->_impl_.monster_);
  swap(_impl_.room_id_, other->_impl_.room_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SLoad::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[9]);
}

// ===================================================================

class CLoad::_Internal {
 public:
  static const ::protocol::Position& position(const CLoad* msg);
};

const ::protocol::Position&
CLoad::_Internal::position(const CLoad* msg) {
  return *msg->_impl_.position_;
}
CLoad::CLoad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.CLoad)
}
CLoad::CLoad(const CLoad& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CLoad* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.code_){}
    , decltype(_impl_.is_dummy_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::protocol::Position(*from._impl_.position_);
  }
  ::memcpy(&_impl_.code_, &from._impl_.code_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_dummy_) -
    reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.is_dummy_));
  // @@protoc_insertion_point(copy_constructor:protocol.CLoad)
}

inline void CLoad::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.code_){0}
    , decltype(_impl_.is_dummy_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CLoad::~CLoad() {
  // @@protoc_insertion_point(destructor:protocol.CLoad)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CLoad::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void CLoad::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CLoad::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.CLoad)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  ::memset(&_impl_.code_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_dummy_) -
      reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.is_dummy_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CLoad::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .protocol.Position position = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_dummy = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.is_dummy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CLoad::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.CLoad)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
  }

  // .protocol.Position position = 100;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(100, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // bool is_dummy = 101;
  if (this->_internal_is_dummy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(101, this->_internal_is_dummy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.CLoad)
  return target;
}

size_t CLoad::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.CLoad)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protocol.Position position = 100;
  if (this->_internal_has_position()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  // bool is_dummy = 101;
  if (this->_internal_is_dummy() != 0) {
    total_size += 2 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CLoad::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CLoad::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CLoad::GetClassData() const { return &_class_data_; }


void CLoad::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CLoad*>(&to_msg);
  auto& from = static_cast<const CLoad&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.CLoad)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::protocol::Position::MergeFrom(
        from._internal_position());
  }
  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  if (from._internal_is_dummy() != 0) {
    _this->_internal_set_is_dummy(from._internal_is_dummy());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CLoad::CopyFrom(const CLoad& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.CLoad)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CLoad::IsInitialized() const {
  return true;
}

void CLoad::InternalSwap(CLoad* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CLoad, _impl_.is_dummy_)
      + sizeof(CLoad::_impl_.is_dummy_)
      - PROTOBUF_FIELD_OFFSET(CLoad, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CLoad::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[10]);
}

// ===================================================================

class SInsertplayer::_Internal {
 public:
  static const ::protocol::Player& player(const SInsertplayer* msg);
};

const ::protocol::Player&
SInsertplayer::_Internal::player(const SInsertplayer* msg) {
  return *msg->_impl_.player_;
}
SInsertplayer::SInsertplayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SInsertplayer)
}
SInsertplayer::SInsertplayer(const SInsertplayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SInsertplayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.player_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_player()) {
    _this->_impl_.player_ = new ::protocol::Player(*from._impl_.player_);
  }
  // @@protoc_insertion_point(copy_constructor:protocol.SInsertplayer)
}

inline void SInsertplayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.player_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SInsertplayer::~SInsertplayer() {
  // @@protoc_insertion_point(destructor:protocol.SInsertplayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SInsertplayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.player_;
}

void SInsertplayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SInsertplayer::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SInsertplayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SInsertplayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protocol.Player player = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SInsertplayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SInsertplayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protocol.Player player = 1;
  if (this->_internal_has_player()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player(this),
        _Internal::player(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SInsertplayer)
  return target;
}

size_t SInsertplayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SInsertplayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protocol.Player player = 1;
  if (this->_internal_has_player()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SInsertplayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SInsertplayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SInsertplayer::GetClassData() const { return &_class_data_; }


void SInsertplayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SInsertplayer*>(&to_msg);
  auto& from = static_cast<const SInsertplayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SInsertplayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_player()) {
    _this->_internal_mutable_player()->::protocol::Player::MergeFrom(
        from._internal_player());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SInsertplayer::CopyFrom(const SInsertplayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SInsertplayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SInsertplayer::IsInitialized() const {
  return true;
}

void SInsertplayer::InternalSwap(SInsertplayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.player_, other->_impl_.player_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SInsertplayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[11]);
}

// ===================================================================

class SMove::_Internal {
 public:
  static const ::protocol::Position& position(const SMove* msg);
};

const ::protocol::Position&
SMove::_Internal::position(const SMove* msg) {
  return *msg->_impl_.position_;
}
SMove::SMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SMove)
}
SMove::SMove(const SMove& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SMove* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.code_){}
    , decltype(_impl_.is_monster_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::protocol::Position(*from._impl_.position_);
  }
  ::memcpy(&_impl_.code_, &from._impl_.code_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_monster_) -
    reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.is_monster_));
  // @@protoc_insertion_point(copy_constructor:protocol.SMove)
}

inline void SMove::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.code_){0}
    , decltype(_impl_.is_monster_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SMove::~SMove() {
  // @@protoc_insertion_point(destructor:protocol.SMove)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SMove::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void SMove::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SMove::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SMove)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  ::memset(&_impl_.code_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_monster_) -
      reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.is_monster_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SMove::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .protocol.Position position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_monster = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.is_monster_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SMove::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SMove)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
  }

  // .protocol.Position position = 2;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // bool is_monster = 3;
  if (this->_internal_is_monster() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_monster(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SMove)
  return target;
}

size_t SMove::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SMove)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protocol.Position position = 2;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  // bool is_monster = 3;
  if (this->_internal_is_monster() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SMove::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SMove::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SMove::GetClassData() const { return &_class_data_; }


void SMove::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SMove*>(&to_msg);
  auto& from = static_cast<const SMove&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SMove)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::protocol::Position::MergeFrom(
        from._internal_position());
  }
  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  if (from._internal_is_monster() != 0) {
    _this->_internal_set_is_monster(from._internal_is_monster());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SMove::CopyFrom(const SMove& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SMove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SMove::IsInitialized() const {
  return true;
}

void SMove::InternalSwap(SMove* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SMove, _impl_.is_monster_)
      + sizeof(SMove::_impl_.is_monster_)
      - PROTOBUF_FIELD_OFFSET(SMove, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SMove::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[12]);
}

// ===================================================================

class SChat::_Internal {
 public:
};

SChat::SChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SChat)
}
SChat::SChat(const SChat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SChat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.text_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_text().empty()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.code_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.code_));
  // @@protoc_insertion_point(copy_constructor:protocol.SChat)
}

inline void SChat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.text_){}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SChat::~SChat() {
  // @@protoc_insertion_point(destructor:protocol.SChat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SChat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
}

void SChat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SChat::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SChat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.text_.ClearToEmpty();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.code_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.code_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SChat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string text = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "protocol.SChat.text"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SChat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SChat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // int32 code = 2;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_code(), target);
  }

  // string text = 5;
  if (!this->_internal_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "protocol.SChat.text");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SChat)
  return target;
}

size_t SChat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SChat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string text = 5;
  if (!this->_internal_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  // uint32 type = 1;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  // int32 code = 2;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SChat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SChat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SChat::GetClassData() const { return &_class_data_; }


void SChat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SChat*>(&to_msg);
  auto& from = static_cast<const SChat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SChat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_text().empty()) {
    _this->_internal_set_text(from._internal_text());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SChat::CopyFrom(const SChat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SChat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SChat::IsInitialized() const {
  return true;
}

void SChat::InternalSwap(SChat* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SChat, _impl_.code_)
      + sizeof(SChat::_impl_.code_)
      - PROTOBUF_FIELD_OFFSET(SChat, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SChat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[13]);
}

// ===================================================================

class SPlayerData::_Internal {
 public:
  static const ::protocol::Player& player(const SPlayerData* msg);
};

const ::protocol::Player&
SPlayerData::_Internal::player(const SPlayerData* msg) {
  return *msg->_impl_.player_;
}
SPlayerData::SPlayerData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SPlayerData)
}
SPlayerData::SPlayerData(const SPlayerData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SPlayerData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.player_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_player()) {
    _this->_impl_.player_ = new ::protocol::Player(*from._impl_.player_);
  }
  // @@protoc_insertion_point(copy_constructor:protocol.SPlayerData)
}

inline void SPlayerData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.player_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SPlayerData::~SPlayerData() {
  // @@protoc_insertion_point(destructor:protocol.SPlayerData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SPlayerData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.player_;
}

void SPlayerData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SPlayerData::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SPlayerData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SPlayerData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protocol.Player player = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SPlayerData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SPlayerData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protocol.Player player = 1;
  if (this->_internal_has_player()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player(this),
        _Internal::player(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SPlayerData)
  return target;
}

size_t SPlayerData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SPlayerData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protocol.Player player = 1;
  if (this->_internal_has_player()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SPlayerData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SPlayerData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SPlayerData::GetClassData() const { return &_class_data_; }


void SPlayerData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SPlayerData*>(&to_msg);
  auto& from = static_cast<const SPlayerData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SPlayerData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_player()) {
    _this->_internal_mutable_player()->::protocol::Player::MergeFrom(
        from._internal_player());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SPlayerData::CopyFrom(const SPlayerData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SPlayerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SPlayerData::IsInitialized() const {
  return true;
}

void SPlayerData::InternalSwap(SPlayerData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.player_, other->_impl_.player_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SPlayerData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[14]);
}

// ===================================================================

class SClosePlayer::_Internal {
 public:
};

SClosePlayer::SClosePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SClosePlayer)
}
SClosePlayer::SClosePlayer(const SClosePlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SClosePlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.code_ = from._impl_.code_;
  // @@protoc_insertion_point(copy_constructor:protocol.SClosePlayer)
}

inline void SClosePlayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SClosePlayer::~SClosePlayer() {
  // @@protoc_insertion_point(destructor:protocol.SClosePlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SClosePlayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SClosePlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SClosePlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SClosePlayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.code_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SClosePlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SClosePlayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SClosePlayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SClosePlayer)
  return target;
}

size_t SClosePlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SClosePlayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SClosePlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SClosePlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SClosePlayer::GetClassData() const { return &_class_data_; }


void SClosePlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SClosePlayer*>(&to_msg);
  auto& from = static_cast<const SClosePlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SClosePlayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SClosePlayer::CopyFrom(const SClosePlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SClosePlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SClosePlayer::IsInitialized() const {
  return true;
}

void SClosePlayer::InternalSwap(SClosePlayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.code_, other->_impl_.code_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SClosePlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[15]);
}

// ===================================================================

class UnitState::_Internal {
 public:
  static const ::protocol::Monster& monster(const UnitState* msg);
  static const ::protocol::Player& player(const UnitState* msg);
};

const ::protocol::Monster&
UnitState::_Internal::monster(const UnitState* msg) {
  return *msg->_impl_.monster_;
}
const ::protocol::Player&
UnitState::_Internal::player(const UnitState* msg) {
  return *msg->_impl_.player_;
}
UnitState::UnitState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.UnitState)
}
UnitState::UnitState(const UnitState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UnitState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.monster_){nullptr}
    , decltype(_impl_.player_){nullptr}
    , decltype(_impl_.demage_){}
    , decltype(_impl_.heal_){}
    , decltype(_impl_.is_monster_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_monster()) {
    _this->_impl_.monster_ = new ::protocol::Monster(*from._impl_.monster_);
  }
  if (from._internal_has_player()) {
    _this->_impl_.player_ = new ::protocol::Player(*from._impl_.player_);
  }
  ::memcpy(&_impl_.demage_, &from._impl_.demage_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_monster_) -
    reinterpret_cast<char*>(&_impl_.demage_)) + sizeof(_impl_.is_monster_));
  // @@protoc_insertion_point(copy_constructor:protocol.UnitState)
}

inline void UnitState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.monster_){nullptr}
    , decltype(_impl_.player_){nullptr}
    , decltype(_impl_.demage_){0}
    , decltype(_impl_.heal_){0}
    , decltype(_impl_.is_monster_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UnitState::~UnitState() {
  // @@protoc_insertion_point(destructor:protocol.UnitState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnitState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.monster_;
  if (this != internal_default_instance()) delete _impl_.player_;
}

void UnitState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnitState::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.UnitState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.monster_ != nullptr) {
    delete _impl_.monster_;
  }
  _impl_.monster_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
  ::memset(&_impl_.demage_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_monster_) -
      reinterpret_cast<char*>(&_impl_.demage_)) + sizeof(_impl_.is_monster_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnitState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protocol.Monster monster = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_monster(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .protocol.Player player = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_player(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 demage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.demage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 heal = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.heal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_monster = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.is_monster_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnitState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.UnitState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protocol.Monster monster = 1;
  if (this->_internal_has_monster()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::monster(this),
        _Internal::monster(this).GetCachedSize(), target, stream);
  }

  // .protocol.Player player = 2;
  if (this->_internal_has_player()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::player(this),
        _Internal::player(this).GetCachedSize(), target, stream);
  }

  // int32 demage = 4;
  if (this->_internal_demage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_demage(), target);
  }

  // int32 heal = 5;
  if (this->_internal_heal() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_heal(), target);
  }

  // bool is_monster = 10;
  if (this->_internal_is_monster() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_is_monster(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.UnitState)
  return target;
}

size_t UnitState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.UnitState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protocol.Monster monster = 1;
  if (this->_internal_has_monster()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.monster_);
  }

  // .protocol.Player player = 2;
  if (this->_internal_has_player()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_);
  }

  // int32 demage = 4;
  if (this->_internal_demage() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_demage());
  }

  // int32 heal = 5;
  if (this->_internal_heal() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_heal());
  }

  // bool is_monster = 10;
  if (this->_internal_is_monster() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnitState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UnitState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnitState::GetClassData() const { return &_class_data_; }


void UnitState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UnitState*>(&to_msg);
  auto& from = static_cast<const UnitState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.UnitState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_monster()) {
    _this->_internal_mutable_monster()->::protocol::Monster::MergeFrom(
        from._internal_monster());
  }
  if (from._internal_has_player()) {
    _this->_internal_mutable_player()->::protocol::Player::MergeFrom(
        from._internal_player());
  }
  if (from._internal_demage() != 0) {
    _this->_internal_set_demage(from._internal_demage());
  }
  if (from._internal_heal() != 0) {
    _this->_internal_set_heal(from._internal_heal());
  }
  if (from._internal_is_monster() != 0) {
    _this->_internal_set_is_monster(from._internal_is_monster());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnitState::CopyFrom(const UnitState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.UnitState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnitState::IsInitialized() const {
  return true;
}

void UnitState::InternalSwap(UnitState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnitState, _impl_.is_monster_)
      + sizeof(UnitState::_impl_.is_monster_)
      - PROTOBUF_FIELD_OFFSET(UnitState, _impl_.monster_)>(
          reinterpret_cast<char*>(&_impl_.monster_),
          reinterpret_cast<char*>(&other->_impl_.monster_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UnitState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[16]);
}

// ===================================================================

class SUnitStates::_Internal {
 public:
};

SUnitStates::SUnitStates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SUnitStates)
}
SUnitStates::SUnitStates(const SUnitStates& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SUnitStates* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.unit_state_){from._impl_.unit_state_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.SUnitStates)
}

inline void SUnitStates::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.unit_state_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SUnitStates::~SUnitStates() {
  // @@protoc_insertion_point(destructor:protocol.SUnitStates)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SUnitStates::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.unit_state_.~RepeatedPtrField();
}

void SUnitStates::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SUnitStates::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SUnitStates)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.unit_state_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SUnitStates::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protocol.UnitState unit_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_unit_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SUnitStates::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SUnitStates)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.UnitState unit_state = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_unit_state_size()); i < n; i++) {
    const auto& repfield = this->_internal_unit_state(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SUnitStates)
  return target;
}

size_t SUnitStates::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SUnitStates)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.UnitState unit_state = 1;
  total_size += 1UL * this->_internal_unit_state_size();
  for (const auto& msg : this->_impl_.unit_state_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SUnitStates::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SUnitStates::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SUnitStates::GetClassData() const { return &_class_data_; }


void SUnitStates::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SUnitStates*>(&to_msg);
  auto& from = static_cast<const SUnitStates&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SUnitStates)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.unit_state_.MergeFrom(from._impl_.unit_state_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SUnitStates::CopyFrom(const SUnitStates& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SUnitStates)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SUnitStates::IsInitialized() const {
  return true;
}

void SUnitStates::InternalSwap(SUnitStates* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.unit_state_.InternalSwap(&other->_impl_.unit_state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SUnitStates::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[17]);
}

// ===================================================================

class Attack::_Internal {
 public:
  static const ::protocol::Position& position(const Attack* msg);
};

const ::protocol::Position&
Attack::_Internal::position(const Attack* msg) {
  return *msg->_impl_.position_;
}
Attack::Attack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.Attack)
}
Attack::Attack(const Attack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Attack* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.code_){}
    , decltype(_impl_.skill_code_){}
    , decltype(_impl_.is_monster_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::protocol::Position(*from._impl_.position_);
  }
  ::memcpy(&_impl_.code_, &from._impl_.code_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_monster_) -
    reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.is_monster_));
  // @@protoc_insertion_point(copy_constructor:protocol.Attack)
}

inline void Attack::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.code_){0}
    , decltype(_impl_.skill_code_){0}
    , decltype(_impl_.is_monster_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Attack::~Attack() {
  // @@protoc_insertion_point(destructor:protocol.Attack)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Attack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void Attack::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Attack::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.Attack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  ::memset(&_impl_.code_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_monster_) -
      reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.is_monster_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Attack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 skill_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.skill_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_monster = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.is_monster_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .protocol.Position position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Attack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Attack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
  }

  // int32 skill_code = 2;
  if (this->_internal_skill_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_skill_code(), target);
  }

  // bool is_monster = 3;
  if (this->_internal_is_monster() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_monster(), target);
  }

  // .protocol.Position position = 4;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Attack)
  return target;
}

size_t Attack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.Attack)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protocol.Position position = 4;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  // int32 skill_code = 2;
  if (this->_internal_skill_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_skill_code());
  }

  // bool is_monster = 3;
  if (this->_internal_is_monster() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Attack::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Attack::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Attack::GetClassData() const { return &_class_data_; }


void Attack::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Attack*>(&to_msg);
  auto& from = static_cast<const Attack&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.Attack)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::protocol::Position::MergeFrom(
        from._internal_position());
  }
  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  if (from._internal_skill_code() != 0) {
    _this->_internal_set_skill_code(from._internal_skill_code());
  }
  if (from._internal_is_monster() != 0) {
    _this->_internal_set_is_monster(from._internal_is_monster());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Attack::CopyFrom(const Attack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.Attack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attack::IsInitialized() const {
  return true;
}

void Attack::InternalSwap(Attack* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Attack, _impl_.is_monster_)
      + sizeof(Attack::_impl_.is_monster_)
      - PROTOBUF_FIELD_OFFSET(Attack, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Attack::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[18]);
}

// ===================================================================

class Buff::_Internal {
 public:
};

Buff::Buff(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.Buff)
}
Buff::Buff(const Buff& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Buff* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.code_){}
    , decltype(_impl_.skill_code_){}
    , decltype(_impl_.is_monster_){}
    , decltype(_impl_.heal_){}
    , decltype(_impl_.hp_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.code_, &from._impl_.code_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hp_) -
    reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.hp_));
  // @@protoc_insertion_point(copy_constructor:protocol.Buff)
}

inline void Buff::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.code_){0}
    , decltype(_impl_.skill_code_){0}
    , decltype(_impl_.is_monster_){false}
    , decltype(_impl_.heal_){0}
    , decltype(_impl_.hp_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Buff::~Buff() {
  // @@protoc_insertion_point(destructor:protocol.Buff)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Buff::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Buff::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Buff::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.Buff)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.code_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.hp_) -
      reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.hp_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Buff::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 skill_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.skill_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_monster = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.is_monster_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 heal = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.heal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 hp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.hp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Buff::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Buff)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
  }

  // int32 skill_code = 2;
  if (this->_internal_skill_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_skill_code(), target);
  }

  // bool is_monster = 3;
  if (this->_internal_is_monster() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_monster(), target);
  }

  // int32 heal = 4;
  if (this->_internal_heal() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_heal(), target);
  }

  // int32 hp = 5;
  if (this->_internal_hp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_hp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Buff)
  return target;
}

size_t Buff::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.Buff)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  // int32 skill_code = 2;
  if (this->_internal_skill_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_skill_code());
  }

  // bool is_monster = 3;
  if (this->_internal_is_monster() != 0) {
    total_size += 1 + 1;
  }

  // int32 heal = 4;
  if (this->_internal_heal() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_heal());
  }

  // int32 hp = 5;
  if (this->_internal_hp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Buff::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Buff::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Buff::GetClassData() const { return &_class_data_; }


void Buff::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Buff*>(&to_msg);
  auto& from = static_cast<const Buff&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.Buff)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  if (from._internal_skill_code() != 0) {
    _this->_internal_set_skill_code(from._internal_skill_code());
  }
  if (from._internal_is_monster() != 0) {
    _this->_internal_set_is_monster(from._internal_is_monster());
  }
  if (from._internal_heal() != 0) {
    _this->_internal_set_heal(from._internal_heal());
  }
  if (from._internal_hp() != 0) {
    _this->_internal_set_hp(from._internal_hp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Buff::CopyFrom(const Buff& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.Buff)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Buff::IsInitialized() const {
  return true;
}

void Buff::InternalSwap(Buff* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Buff, _impl_.hp_)
      + sizeof(Buff::_impl_.hp_)
      - PROTOBUF_FIELD_OFFSET(Buff, _impl_.code_)>(
          reinterpret_cast<char*>(&_impl_.code_),
          reinterpret_cast<char*>(&other->_impl_.code_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Buff::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[19]);
}

// ===================================================================

class CPlayerAttack::_Internal {
 public:
  static const ::protocol::Position& position(const CPlayerAttack* msg);
};

const ::protocol::Position&
CPlayerAttack::_Internal::position(const CPlayerAttack* msg) {
  return *msg->_impl_.position_;
}
CPlayerAttack::CPlayerAttack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.CPlayerAttack)
}
CPlayerAttack::CPlayerAttack(const CPlayerAttack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CPlayerAttack* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.code_){}
    , decltype(_impl_.skill_code_){}
    , decltype(_impl_.target_code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::protocol::Position(*from._impl_.position_);
  }
  ::memcpy(&_impl_.code_, &from._impl_.code_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_code_) -
    reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.target_code_));
  // @@protoc_insertion_point(copy_constructor:protocol.CPlayerAttack)
}

inline void CPlayerAttack::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.code_){0}
    , decltype(_impl_.skill_code_){0}
    , decltype(_impl_.target_code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CPlayerAttack::~CPlayerAttack() {
  // @@protoc_insertion_point(destructor:protocol.CPlayerAttack)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CPlayerAttack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void CPlayerAttack::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CPlayerAttack::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.CPlayerAttack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  ::memset(&_impl_.code_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.target_code_) -
      reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.target_code_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CPlayerAttack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 skill_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.skill_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 target_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.target_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .protocol.Position position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CPlayerAttack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.CPlayerAttack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
  }

  // int32 skill_code = 2;
  if (this->_internal_skill_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_skill_code(), target);
  }

  // int32 target_code = 3;
  if (this->_internal_target_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_target_code(), target);
  }

  // .protocol.Position position = 4;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.CPlayerAttack)
  return target;
}

size_t CPlayerAttack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.CPlayerAttack)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protocol.Position position = 4;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  // int32 skill_code = 2;
  if (this->_internal_skill_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_skill_code());
  }

  // int32 target_code = 3;
  if (this->_internal_target_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CPlayerAttack::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CPlayerAttack::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CPlayerAttack::GetClassData() const { return &_class_data_; }


void CPlayerAttack::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CPlayerAttack*>(&to_msg);
  auto& from = static_cast<const CPlayerAttack&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.CPlayerAttack)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::protocol::Position::MergeFrom(
        from._internal_position());
  }
  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  if (from._internal_skill_code() != 0) {
    _this->_internal_set_skill_code(from._internal_skill_code());
  }
  if (from._internal_target_code() != 0) {
    _this->_internal_set_target_code(from._internal_target_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CPlayerAttack::CopyFrom(const CPlayerAttack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.CPlayerAttack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CPlayerAttack::IsInitialized() const {
  return true;
}

void CPlayerAttack::InternalSwap(CPlayerAttack* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CPlayerAttack, _impl_.target_code_)
      + sizeof(CPlayerAttack::_impl_.target_code_)
      - PROTOBUF_FIELD_OFFSET(CPlayerAttack, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CPlayerAttack::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[20]);
}

// ===================================================================

class SUnitAttack::_Internal {
 public:
};

SUnitAttack::SUnitAttack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SUnitAttack)
}
SUnitAttack::SUnitAttack(const SUnitAttack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SUnitAttack* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.attack_){from._impl_.attack_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.SUnitAttack)
}

inline void SUnitAttack::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.attack_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SUnitAttack::~SUnitAttack() {
  // @@protoc_insertion_point(destructor:protocol.SUnitAttack)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SUnitAttack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attack_.~RepeatedPtrField();
}

void SUnitAttack::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SUnitAttack::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SUnitAttack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attack_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SUnitAttack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protocol.Attack attack = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attack(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SUnitAttack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SUnitAttack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.Attack attack = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attack_size()); i < n; i++) {
    const auto& repfield = this->_internal_attack(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SUnitAttack)
  return target;
}

size_t SUnitAttack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SUnitAttack)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.Attack attack = 1;
  total_size += 1UL * this->_internal_attack_size();
  for (const auto& msg : this->_impl_.attack_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SUnitAttack::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SUnitAttack::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SUnitAttack::GetClassData() const { return &_class_data_; }


void SUnitAttack::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SUnitAttack*>(&to_msg);
  auto& from = static_cast<const SUnitAttack&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SUnitAttack)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attack_.MergeFrom(from._impl_.attack_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SUnitAttack::CopyFrom(const SUnitAttack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SUnitAttack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SUnitAttack::IsInitialized() const {
  return true;
}

void SUnitAttack::InternalSwap(SUnitAttack* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.attack_.InternalSwap(&other->_impl_.attack_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SUnitAttack::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[21]);
}

// ===================================================================

class SUnitBuff::_Internal {
 public:
};

SUnitBuff::SUnitBuff(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SUnitBuff)
}
SUnitBuff::SUnitBuff(const SUnitBuff& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SUnitBuff* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.buff_){from._impl_.buff_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.SUnitBuff)
}

inline void SUnitBuff::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.buff_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SUnitBuff::~SUnitBuff() {
  // @@protoc_insertion_point(destructor:protocol.SUnitBuff)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SUnitBuff::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.buff_.~RepeatedPtrField();
}

void SUnitBuff::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SUnitBuff::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SUnitBuff)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.buff_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SUnitBuff::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protocol.Buff buff = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buff(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SUnitBuff::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SUnitBuff)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.Buff buff = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buff_size()); i < n; i++) {
    const auto& repfield = this->_internal_buff(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SUnitBuff)
  return target;
}

size_t SUnitBuff::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SUnitBuff)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.Buff buff = 1;
  total_size += 1UL * this->_internal_buff_size();
  for (const auto& msg : this->_impl_.buff_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SUnitBuff::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SUnitBuff::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SUnitBuff::GetClassData() const { return &_class_data_; }


void SUnitBuff::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SUnitBuff*>(&to_msg);
  auto& from = static_cast<const SUnitBuff&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SUnitBuff)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.buff_.MergeFrom(from._impl_.buff_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SUnitBuff::CopyFrom(const SUnitBuff& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SUnitBuff)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SUnitBuff::IsInitialized() const {
  return true;
}

void SUnitBuff::InternalSwap(SUnitBuff* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.buff_.InternalSwap(&other->_impl_.buff_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SUnitBuff::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[22]);
}

// ===================================================================

class Demage::_Internal {
 public:
};

Demage::Demage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.Demage)
}
Demage::Demage(const Demage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Demage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.code_){}
    , decltype(_impl_.demage_){}
    , decltype(_impl_.is_monster_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.code_, &from._impl_.code_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_monster_) -
    reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.is_monster_));
  // @@protoc_insertion_point(copy_constructor:protocol.Demage)
}

inline void Demage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.code_){0}
    , decltype(_impl_.demage_){0}
    , decltype(_impl_.is_monster_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Demage::~Demage() {
  // @@protoc_insertion_point(destructor:protocol.Demage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Demage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Demage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Demage::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.Demage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.code_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_monster_) -
      reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.is_monster_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Demage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 demage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.demage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_monster = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.is_monster_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Demage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Demage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
  }

  // int32 demage = 2;
  if (this->_internal_demage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_demage(), target);
  }

  // bool is_monster = 3;
  if (this->_internal_is_monster() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_monster(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Demage)
  return target;
}

size_t Demage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.Demage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  // int32 demage = 2;
  if (this->_internal_demage() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_demage());
  }

  // bool is_monster = 3;
  if (this->_internal_is_monster() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Demage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Demage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Demage::GetClassData() const { return &_class_data_; }


void Demage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Demage*>(&to_msg);
  auto& from = static_cast<const Demage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.Demage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  if (from._internal_demage() != 0) {
    _this->_internal_set_demage(from._internal_demage());
  }
  if (from._internal_is_monster() != 0) {
    _this->_internal_set_is_monster(from._internal_is_monster());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Demage::CopyFrom(const Demage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.Demage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Demage::IsInitialized() const {
  return true;
}

void Demage::InternalSwap(Demage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Demage, _impl_.is_monster_)
      + sizeof(Demage::_impl_.is_monster_)
      - PROTOBUF_FIELD_OFFSET(Demage, _impl_.code_)>(
          reinterpret_cast<char*>(&_impl_.code_),
          reinterpret_cast<char*>(&other->_impl_.code_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Demage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[23]);
}

// ===================================================================

class SUnitDemage::_Internal {
 public:
  static const ::protocol::Demage& demage(const SUnitDemage* msg);
};

const ::protocol::Demage&
SUnitDemage::_Internal::demage(const SUnitDemage* msg) {
  return *msg->_impl_.demage_;
}
SUnitDemage::SUnitDemage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SUnitDemage)
}
SUnitDemage::SUnitDemage(const SUnitDemage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SUnitDemage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.demage_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_demage()) {
    _this->_impl_.demage_ = new ::protocol::Demage(*from._impl_.demage_);
  }
  // @@protoc_insertion_point(copy_constructor:protocol.SUnitDemage)
}

inline void SUnitDemage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.demage_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SUnitDemage::~SUnitDemage() {
  // @@protoc_insertion_point(destructor:protocol.SUnitDemage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SUnitDemage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.demage_;
}

void SUnitDemage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SUnitDemage::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SUnitDemage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.demage_ != nullptr) {
    delete _impl_.demage_;
  }
  _impl_.demage_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SUnitDemage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .protocol.Demage demage = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_demage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SUnitDemage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SUnitDemage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .protocol.Demage demage = 1;
  if (this->_internal_has_demage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::demage(this),
        _Internal::demage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SUnitDemage)
  return target;
}

size_t SUnitDemage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SUnitDemage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .protocol.Demage demage = 1;
  if (this->_internal_has_demage()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.demage_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SUnitDemage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SUnitDemage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SUnitDemage::GetClassData() const { return &_class_data_; }


void SUnitDemage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SUnitDemage*>(&to_msg);
  auto& from = static_cast<const SUnitDemage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SUnitDemage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_demage()) {
    _this->_internal_mutable_demage()->::protocol::Demage::MergeFrom(
        from._internal_demage());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SUnitDemage::CopyFrom(const SUnitDemage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SUnitDemage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SUnitDemage::IsInitialized() const {
  return true;
}

void SUnitDemage::InternalSwap(SUnitDemage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.demage_, other->_impl_.demage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SUnitDemage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[24]);
}

// ===================================================================

class SRoomQuest::_Internal {
 public:
};

SRoomQuest::SRoomQuest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SRoomQuest)
}
SRoomQuest::SRoomQuest(const SRoomQuest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SRoomQuest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.is_clear_){}
    , decltype(_impl_.kill_count_){}
    , decltype(_impl_.sum_kill_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.is_clear_, &from._impl_.is_clear_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sum_kill_) -
    reinterpret_cast<char*>(&_impl_.is_clear_)) + sizeof(_impl_.sum_kill_));
  // @@protoc_insertion_point(copy_constructor:protocol.SRoomQuest)
}

inline void SRoomQuest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.is_clear_){false}
    , decltype(_impl_.kill_count_){0}
    , decltype(_impl_.sum_kill_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SRoomQuest::~SRoomQuest() {
  // @@protoc_insertion_point(destructor:protocol.SRoomQuest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SRoomQuest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SRoomQuest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SRoomQuest::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SRoomQuest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.is_clear_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.sum_kill_) -
      reinterpret_cast<char*>(&_impl_.is_clear_)) + sizeof(_impl_.sum_kill_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SRoomQuest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool is_clear = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.is_clear_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 kill_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.kill_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 sum_kill = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.sum_kill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SRoomQuest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SRoomQuest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool is_clear = 1;
  if (this->_internal_is_clear() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_clear(), target);
  }

  // int32 kill_count = 2;
  if (this->_internal_kill_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_kill_count(), target);
  }

  // int32 sum_kill = 3;
  if (this->_internal_sum_kill() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_sum_kill(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SRoomQuest)
  return target;
}

size_t SRoomQuest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SRoomQuest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool is_clear = 1;
  if (this->_internal_is_clear() != 0) {
    total_size += 1 + 1;
  }

  // int32 kill_count = 2;
  if (this->_internal_kill_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_kill_count());
  }

  // int32 sum_kill = 3;
  if (this->_internal_sum_kill() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sum_kill());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SRoomQuest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SRoomQuest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SRoomQuest::GetClassData() const { return &_class_data_; }


void SRoomQuest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SRoomQuest*>(&to_msg);
  auto& from = static_cast<const SRoomQuest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SRoomQuest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_is_clear() != 0) {
    _this->_internal_set_is_clear(from._internal_is_clear());
  }
  if (from._internal_kill_count() != 0) {
    _this->_internal_set_kill_count(from._internal_kill_count());
  }
  if (from._internal_sum_kill() != 0) {
    _this->_internal_set_sum_kill(from._internal_sum_kill());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SRoomQuest::CopyFrom(const SRoomQuest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SRoomQuest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SRoomQuest::IsInitialized() const {
  return true;
}

void SRoomQuest::InternalSwap(SRoomQuest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SRoomQuest, _impl_.sum_kill_)
      + sizeof(SRoomQuest::_impl_.sum_kill_)
      - PROTOBUF_FIELD_OFFSET(SRoomQuest, _impl_.is_clear_)>(
          reinterpret_cast<char*>(&_impl_.is_clear_),
          reinterpret_cast<char*>(&other->_impl_.is_clear_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SRoomQuest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[25]);
}

// ===================================================================

class CMovePotal::_Internal {
 public:
};

CMovePotal::CMovePotal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.CMovePotal)
}
CMovePotal::CMovePotal(const CMovePotal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMovePotal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pre_room_id_){}
    , decltype(_impl_.next_room_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.pre_room_id_, &from._impl_.pre_room_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.next_room_id_) -
    reinterpret_cast<char*>(&_impl_.pre_room_id_)) + sizeof(_impl_.next_room_id_));
  // @@protoc_insertion_point(copy_constructor:protocol.CMovePotal)
}

inline void CMovePotal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pre_room_id_){0}
    , decltype(_impl_.next_room_id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMovePotal::~CMovePotal() {
  // @@protoc_insertion_point(destructor:protocol.CMovePotal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMovePotal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMovePotal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMovePotal::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.CMovePotal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.pre_room_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.next_room_id_) -
      reinterpret_cast<char*>(&_impl_.pre_room_id_)) + sizeof(_impl_.next_room_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMovePotal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 pre_room_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.pre_room_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 next_room_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.next_room_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMovePotal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.CMovePotal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 pre_room_id = 1;
  if (this->_internal_pre_room_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_pre_room_id(), target);
  }

  // int32 next_room_id = 2;
  if (this->_internal_next_room_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_next_room_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.CMovePotal)
  return target;
}

size_t CMovePotal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.CMovePotal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 pre_room_id = 1;
  if (this->_internal_pre_room_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pre_room_id());
  }

  // int32 next_room_id = 2;
  if (this->_internal_next_room_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_next_room_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMovePotal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMovePotal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMovePotal::GetClassData() const { return &_class_data_; }


void CMovePotal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMovePotal*>(&to_msg);
  auto& from = static_cast<const CMovePotal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.CMovePotal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_pre_room_id() != 0) {
    _this->_internal_set_pre_room_id(from._internal_pre_room_id());
  }
  if (from._internal_next_room_id() != 0) {
    _this->_internal_set_next_room_id(from._internal_next_room_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMovePotal::CopyFrom(const CMovePotal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.CMovePotal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMovePotal::IsInitialized() const {
  return true;
}

void CMovePotal::InternalSwap(CMovePotal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMovePotal, _impl_.next_room_id_)
      + sizeof(CMovePotal::_impl_.next_room_id_)
      - PROTOBUF_FIELD_OFFSET(CMovePotal, _impl_.pre_room_id_)>(
          reinterpret_cast<char*>(&_impl_.pre_room_id_),
          reinterpret_cast<char*>(&other->_impl_.pre_room_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMovePotal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[26]);
}

// ===================================================================

class SEndGame::_Internal {
 public:
};

SEndGame::SEndGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SEndGame)
}
SEndGame::SEndGame(const SEndGame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SEndGame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.end_game_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.end_game_ = from._impl_.end_game_;
  // @@protoc_insertion_point(copy_constructor:protocol.SEndGame)
}

inline void SEndGame::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.end_game_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SEndGame::~SEndGame() {
  // @@protoc_insertion_point(destructor:protocol.SEndGame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SEndGame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SEndGame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SEndGame::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SEndGame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.end_game_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SEndGame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool end_game = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.end_game_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SEndGame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SEndGame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool end_game = 1;
  if (this->_internal_end_game() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_end_game(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SEndGame)
  return target;
}

size_t SEndGame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SEndGame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool end_game = 1;
  if (this->_internal_end_game() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SEndGame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SEndGame::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SEndGame::GetClassData() const { return &_class_data_; }


void SEndGame::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SEndGame*>(&to_msg);
  auto& from = static_cast<const SEndGame&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SEndGame)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_end_game() != 0) {
    _this->_internal_set_end_game(from._internal_end_game());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SEndGame::CopyFrom(const SEndGame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SEndGame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SEndGame::IsInitialized() const {
  return true;
}

void SEndGame::InternalSwap(SEndGame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.end_game_, other->_impl_.end_game_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SEndGame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[27]);
}

// ===================================================================

class Item::_Internal {
 public:
};

Item::Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.Item)
}
Item::Item(const Item& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Item* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.item_code_){}
    , decltype(_impl_.item_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.item_code_, &from._impl_.item_code_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_count_) -
    reinterpret_cast<char*>(&_impl_.item_code_)) + sizeof(_impl_.item_count_));
  // @@protoc_insertion_point(copy_constructor:protocol.Item)
}

inline void Item::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.item_code_){0}
    , decltype(_impl_.item_count_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Item::~Item() {
  // @@protoc_insertion_point(destructor:protocol.Item)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Item::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Item::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Item::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.Item)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.item_code_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.item_count_) -
      reinterpret_cast<char*>(&_impl_.item_code_)) + sizeof(_impl_.item_count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Item::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 item_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.item_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 item_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.item_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Item::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.Item)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 item_code = 1;
  if (this->_internal_item_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_item_code(), target);
  }

  // int32 item_count = 2;
  if (this->_internal_item_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_item_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.Item)
  return target;
}

size_t Item::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.Item)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 item_code = 1;
  if (this->_internal_item_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_code());
  }

  // int32 item_count = 2;
  if (this->_internal_item_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Item::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Item::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Item::GetClassData() const { return &_class_data_; }


void Item::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Item*>(&to_msg);
  auto& from = static_cast<const Item&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.Item)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_item_code() != 0) {
    _this->_internal_set_item_code(from._internal_item_code());
  }
  if (from._internal_item_count() != 0) {
    _this->_internal_set_item_count(from._internal_item_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Item::CopyFrom(const Item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.Item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Item::IsInitialized() const {
  return true;
}

void Item::InternalSwap(Item* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Item, _impl_.item_count_)
      + sizeof(Item::_impl_.item_count_)
      - PROTOBUF_FIELD_OFFSET(Item, _impl_.item_code_)>(
          reinterpret_cast<char*>(&_impl_.item_code_),
          reinterpret_cast<char*>(&other->_impl_.item_code_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Item::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[28]);
}

// ===================================================================

class DropMessage::_Internal {
 public:
};

DropMessage::DropMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.DropMessage)
}
DropMessage::DropMessage(const DropMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DropMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.DropMessage)
}

inline void DropMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DropMessage::~DropMessage() {
  // @@protoc_insertion_point(destructor:protocol.DropMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DropMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void DropMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DropMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.DropMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DropMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protocol.Item items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DropMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.DropMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.Item items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.DropMessage)
  return target;
}

size_t DropMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.DropMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.Item items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DropMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DropMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DropMessage::GetClassData() const { return &_class_data_; }


void DropMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DropMessage*>(&to_msg);
  auto& from = static_cast<const DropMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.DropMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DropMessage::CopyFrom(const DropMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.DropMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropMessage::IsInitialized() const {
  return true;
}

void DropMessage::InternalSwap(DropMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DropMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[29]);
}

// ===================================================================

class SLoadInventory::_Internal {
 public:
};

SLoadInventory::SLoadInventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:protocol.SLoadInventory)
}
SLoadInventory::SLoadInventory(const SLoadInventory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SLoadInventory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.gold_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.gold_ = from._impl_.gold_;
  // @@protoc_insertion_point(copy_constructor:protocol.SLoadInventory)
}

inline void SLoadInventory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , decltype(_impl_.gold_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SLoadInventory::~SLoadInventory() {
  // @@protoc_insertion_point(destructor:protocol.SLoadInventory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SLoadInventory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void SLoadInventory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SLoadInventory::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.SLoadInventory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _impl_.gold_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SLoadInventory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .protocol.Item items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 gold = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SLoadInventory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.SLoadInventory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.Item items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 gold = 2;
  if (this->_internal_gold() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_gold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.SLoadInventory)
  return target;
}

size_t SLoadInventory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.SLoadInventory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.Item items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int32 gold = 2;
  if (this->_internal_gold() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gold());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SLoadInventory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SLoadInventory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SLoadInventory::GetClassData() const { return &_class_data_; }


void SLoadInventory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SLoadInventory*>(&to_msg);
  auto& from = static_cast<const SLoadInventory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:protocol.SLoadInventory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_gold() != 0) {
    _this->_internal_set_gold(from._internal_gold());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SLoadInventory::CopyFrom(const SLoadInventory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.SLoadInventory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SLoadInventory::IsInitialized() const {
  return true;
}

void SLoadInventory::InternalSwap(SLoadInventory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.gold_, other->_impl_.gold_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SLoadInventory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_GameService_2eproto_getter, &descriptor_table_GameService_2eproto_once,
      file_level_metadata_GameService_2eproto[30]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace protocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::protocol::Login*
Arena::CreateMaybeMessage< ::protocol::Login >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::Login >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::CreateAccount*
Arena::CreateMaybeMessage< ::protocol::CreateAccount >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::CreateAccount >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::CreateCharacter*
Arena::CreateMaybeMessage< ::protocol::CreateCharacter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::CreateCharacter >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::LoginAccess*
Arena::CreateMaybeMessage< ::protocol::LoginAccess >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::LoginAccess >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::Charater*
Arena::CreateMaybeMessage< ::protocol::Charater >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::Charater >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::Position*
Arena::CreateMaybeMessage< ::protocol::Position >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::Position >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::Unit*
Arena::CreateMaybeMessage< ::protocol::Unit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::Unit >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::Player*
Arena::CreateMaybeMessage< ::protocol::Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::Player >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::Monster*
Arena::CreateMaybeMessage< ::protocol::Monster >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::Monster >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SLoad*
Arena::CreateMaybeMessage< ::protocol::SLoad >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SLoad >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::CLoad*
Arena::CreateMaybeMessage< ::protocol::CLoad >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::CLoad >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SInsertplayer*
Arena::CreateMaybeMessage< ::protocol::SInsertplayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SInsertplayer >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SMove*
Arena::CreateMaybeMessage< ::protocol::SMove >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SMove >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SChat*
Arena::CreateMaybeMessage< ::protocol::SChat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SChat >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SPlayerData*
Arena::CreateMaybeMessage< ::protocol::SPlayerData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SPlayerData >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SClosePlayer*
Arena::CreateMaybeMessage< ::protocol::SClosePlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SClosePlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::UnitState*
Arena::CreateMaybeMessage< ::protocol::UnitState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::UnitState >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SUnitStates*
Arena::CreateMaybeMessage< ::protocol::SUnitStates >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SUnitStates >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::Attack*
Arena::CreateMaybeMessage< ::protocol::Attack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::Attack >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::Buff*
Arena::CreateMaybeMessage< ::protocol::Buff >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::Buff >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::CPlayerAttack*
Arena::CreateMaybeMessage< ::protocol::CPlayerAttack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::CPlayerAttack >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SUnitAttack*
Arena::CreateMaybeMessage< ::protocol::SUnitAttack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SUnitAttack >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SUnitBuff*
Arena::CreateMaybeMessage< ::protocol::SUnitBuff >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SUnitBuff >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::Demage*
Arena::CreateMaybeMessage< ::protocol::Demage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::Demage >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SUnitDemage*
Arena::CreateMaybeMessage< ::protocol::SUnitDemage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SUnitDemage >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SRoomQuest*
Arena::CreateMaybeMessage< ::protocol::SRoomQuest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SRoomQuest >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::CMovePotal*
Arena::CreateMaybeMessage< ::protocol::CMovePotal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::CMovePotal >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SEndGame*
Arena::CreateMaybeMessage< ::protocol::SEndGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SEndGame >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::Item*
Arena::CreateMaybeMessage< ::protocol::Item >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::Item >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::DropMessage*
Arena::CreateMaybeMessage< ::protocol::DropMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::DropMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::SLoadInventory*
Arena::CreateMaybeMessage< ::protocol::SLoadInventory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::SLoadInventory >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
